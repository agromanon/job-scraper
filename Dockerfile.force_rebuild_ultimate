# Dockerfile.force_rebuild_ultimate - FORCES complete rebuild by changing build context
# This guarantees all templates are recreated fresh every build
# Usage: docker build -f Dockerfile.force_rebuild_ultimate -t jobspy-frontend .

FROM python:3.11-slim

# AGGRESSIVE CACHE INVALIDATION - Unique identifiers that change every build
ARG BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ')
ARG BUILD_EPOCH=$(date +%s)
ARG BUILD_UUID=$(uuidgen)
ARG BUILD_RANDOM=$(head /dev/urandom | tr -dc 'a-zA-Z0-9' | fold -w 64 | head -n 1)
ARG GIT_COMMIT=$(git rev-parse HEAD 2>/dev/null || echo "unknown")
ARG FORCE_REBUILD_TRIGGER=$(date +%s%N)

# Set multiple environment variables to force cache breaks
ENV BUILD_DATE=${BUILD_DATE}
ENV BUILD_EPOCH=${BUILD_EPOCH} 
ENV BUILD_UUID=${BUILD_UUID}
ENV BUILD_RANDOM=${BUILD_RANDOM}
ENV GIT_COMMIT=${GIT_COMMIT}
ENV FORCE_REBUILD_TRIGGER=${FORCE_REBUILD_TRIGGER}

# BREAK ALL CACHES - This RUN command changes every single build
RUN echo "=== COMPLETE FULL REBUILD STARTED ===" && \
    echo "Build Date: ${BUILD_DATE}" && \
    echo "Build Epoch: ${BUILD_EPOCH}" && \
    echo "Build UUID: ${BUILD_UUID}" && \
    echo "Build Random: ${BUILD_RANDOM}" && \
    echo "Git Commit: ${GIT_COMMIT}" && \
    echo "Force Rebuild Trigger: ${FORCE_REBUILD_TRIGGER}" && \
    echo "This build will completely recreate all templates and files" && \
    # Create timestamped rebuild marker
    echo "FULL_REBUILD_TIMESTAMP=$(date -u +'%Y-%m-%dT%H:%M:%SZ')" > /tmp/force_rebuild_marker.txt && \
    # Clean ALL caches completely
    rm -rf /var/cache/apt/* /var/lib/apt/lists/* /tmp/* /var/tmp/* /root/.cache /app/* /app/.git 2>/dev/null || true && \
    # Create directories with fresh permissions
    mkdir -p /app/templates /app/static/css /app/static/js /app/logs && \
    chmod -R 755 /app /app/templates /app/static /app/logs && \
    # Verify rebuild
    echo "Rebuild completed successfully at $(date -u +'%Y-%m-%dT%H:%M:%SZ')" > /tmp/rebuild_verification.txt

# Set working directory
WORKDIR /app

# Install system dependencies (WILL ALWAYS RUN due to cache break above)
RUN apt-get update && apt-get install -y \
    gcc \
    g++ \
    libpq-dev \
    curl \
    git \
    python3-dev \
    && rm -rf /var/lib/apt/lists/*

# Copy requirements (WILL ALWAYS RUN due to cache break)
COPY requirements.admin.txt /app/requirements.admin.txt
COPY requirements.txt /app/requirements.txt

# Install dependencies (WILL ALWAYS RUN due to cache break)
RUN pip install --no-cache-dir --upgrade pip && \
    pip install --no-cache-dir -r requirements.admin.txt && \
    pip install --no-cache-dir -r requirements.txt

# Copy application code (WILL ALWAYS RUN due to cache break)
COPY jobspy/ /app/jobspy/
COPY worker_admin.py /app/
COPY worker_manager.py /app/
COPY modular_schema.sql /app/modular_schema.sql

# Create directories for templates and static files
RUN echo "=== CREATING DIRECTORIES ===" && \
    mkdir -p /app/templates /app/static/css /app/static/js /app/static/images /app/logs && \
    echo "Directories created at $(date -u +'%Y-%m-%dT%H:%M:%SZ')" > /app/templates_recreate_info.txt

# Copy templates and static files
COPY app/templates/ /app/templates/
COPY app/static/ /app/static/

# Ensure proper permissions
RUN chmod -R 755 /app/templates /app/static

# Expose port
EXPOSE 5000

# Add job status checker script
COPY job_status_checker.py /app/
COPY fix_database.py /app/
COPY startup.sh /app/
RUN chmod +x /app/job_status_checker.py /app/fix_database.py /app/startup.sh

# Set up cron for job status checking (runs daily at 2 AM)
RUN apt-get update && apt-get install -y cron
RUN echo "0 2 * * * cd /app && python3 job_status_checker.py >> /var/log/job_status_checker.log 2>&1" > /etc/cron.d/job-status-checker
RUN chmod 0644 /etc/cron.d/job-status-checker
RUN crontab /etc/cron.d/job-status-checker
RUN touch /var/log/job_status_checker.log

# Health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:5000/health || exit 1

# Run the application via startup script
CMD ["/app/startup.sh"]